# Firestore設計ベストプラクティス

**作成日**: 2025-11-19  
**出典**: [Firebase公式ドキュメント](https://firebase.google.com/docs/firestore)  
**目的**: 本プロジェクトのFirestore設計で準拠すべき公式ベストプラクティスをまとめる  
  
---

## 1. データモデル設計

### 基本構造

- **NoSQL、ドキュメント指向データベース**：テーブルや行の概念なし
- **コレクション** → **ドキュメント** → **フィールド**（またはサブコレクション）の階層構造
- ドキュメントは最大1MBのサイズ制限

### ドキュメントID

- `/`（スラッシュ）をIDに含めない
- **単調増加IDを避ける**（Customer1, Customer2など）→ ホットスポットの原因
- Cloud Firestoreの自動ID生成（`doc()`）を使用することを推奨

### フィールド名

- 特殊文字を避ける（ピリオド、括弧、アスタリスク、バッククォート）
- 追加エスケープが必要になり、コード可読性が低下

### 暗黙的な作成

- コレクションやドキュメントは明示的に作成不要
- データを書き込むと自動生成される
- ドキュメントが0件になるとコレクションも消える

---

## 2. コレクション設計パターン

### サブコレクション vs トップレベルコレクション

| パターン | 用途 | 例 |
|---------|------|-----|
| **トップレベルコレクション** | 独立したエンティティ、クロスコレクションクエリが必要 | /chains, /menus |
| **サブコレクション** | 親ドキュメントに強く紐づくデータ、親経由でのみアクセス | /users/{userId}/favorites |

### 参照の使い分け

- **ドキュメント参照**：個別データの読み書き
- **コレクション参照**：クエリ実行

### 非正規化

- **読み取り最適化のため、データを重複させることも有効**
- 例：メニューにチェーン名を埋め込む（chainNameフィールド）
- 更新時の整合性維持が必要になるトレードオフ

---

## 3. 読み書き最適化

### 非同期処理の活用

- 依存関係のない操作は**並列実行**
- Promis.all()で複数の読み取りを同時実行

### オフセット回避

- `offset`は使用しない → **カーソルベースのページネーション**を使用
- スキップされたドキュメントも内部で読み取られ、コストが発生

### トランザクション

- **SDKは失敗したトランザクションを自動再試行**
- 競合が多い場合は再試行回数を考慮
- 読み取り操作は書き込み操作の前に実行

### バッチ書き込み

- 複数のドキュメントを原子的に更新する場合に使用
- 最大500ドキュメントまで

---

## 4. セキュリティルール

### 基本構造

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // ルールをここに記述
  }
}
```

### 操作の種類

| 操作 | 説明 |
|------|------|
| `read` | `get` + `list` |
| `get` | 単一ドキュメントの読み取り |
| `list` | コレクションのクエリ |
| `write` | `create` + `update` + `delete` |
| `create` | 新規ドキュメントの作成 |
| `update` | 既存ドキュメントの更新 |
| `delete` | ドキュメントの削除 |

### サブコレクションの注意点

- **親コレクションのルールはサブコレクションに継承されない**
- 各レベルで明示的にルールを定義する必要がある

### 制限事項

- 各リクエストで最大10回の`exists()`、`get()`、`getAfter()`呼び出し
- ネストされた`match`は最大10レベル
- ルールセットは最大256KB

---

## 5. インデックス設計

### インデックスの種類

| 種類 | 説明 | 作成方法 |
|------|------|----------|
| **単一フィールドインデックス** | 1つのフィールドに対するインデックス | 自動作成 |
| **複合インデックス** | 複数フィールドを組み合わせたインデックス | 手動作成 |

### 単一フィールドインデックス

- **自動的に作成される**
- 各フィールドに対して昇順・降順のインデックスが生成
- 除外設定で不要なインデックスを無効化可能

### 複合インデックス

- **範囲句を含むクエリで必要**
- 例：`where('chainId', '==', 'abc').orderBy('saleStartTime', 'desc')`
- 手動で作成が必要（Firebase Console、CLI、エラーメッセージのリンク）

### インデックス除外が推奨されるケース

- TTL（有効期限）フィールド
- 大規模な配列フィールド
- 長文字列フィールド（1500バイト超）
- クエリで使用しないフィールド

---

## 6. スケーリング対策

### ホットスポット回避

- 単調増加IDを避ける
- トラフィックは段階的に導入

### 500/50/5ルール

新規コレクションへのトラフィック増加は段階的に：
1. 最初は500操作/秒以下
2. 50%ずつ5分ごとに増加

### 読み取り回数の最適化

- 必要なフィールドのみを取得することはできない（ドキュメント単位）
- 頻繁にアクセスするデータは小さなドキュメントに分割
- キャッシュを活用（Firestore SDKのオフラインキャッシュ）

---

## 7. コスト最適化

### 読み取りコストの削減

- **1ドキュメント = 1読み取り**（フィールド数は関係ない）
- クエリ結果が0件でも1読み取りとしてカウント
- リアルタイムリスナーは変更があった場合のみカウント

### 書き込みコストの削減

- バッチ書き込みで複数ドキュメントをまとめて更新
- 不要な更新を避ける（値が変わらない場合は更新しない）

### 削除コストの削減

- サブコレクションは親ドキュメント削除時に自動削除されない
- 大量削除にはCloud Functionsを使用

---

## 8. 本プロジェクトへの適用

### 採用するベストプラクティス

| プラクティス | 適用方法 |
|-------------|---------|
| 自動ID生成 | /menus, /chainsで`doc()`を使用 |
| サブコレクション | /users/{userId}/favoritesでお気に入りを管理 |
| 複合インデックス | chainId + saleStartTimeでフィルタ+ソート |
| トランザクション | お気に入り登録時のfavoriteCount更新 |
| 段階的トラフィック | Phase2のベータリリースで適用 |

### 採用しないもの（Phase2時点）

| プラクティス | 理由 |
|-------------|------|
| 非正規化 | Phase2の規模では不要、整合性維持コストが高い |
| リアルタイムリスナー | Phase2では`getDoc()`のみ使用、Phase3で検討 |
| 大規模バッチ | Phase2では500件超のバッチ処理は不要 |

---

## 参考リンク

- [Firestore ベストプラクティス](https://firebase.google.com/docs/firestore/best-practices)
- [Firestore データモデル](https://firebase.google.com/docs/firestore/data-model)
- [セキュリティルールの構造](https://firebase.google.com/docs/firestore/security/rules-structure)
- [インデックスの管理](https://firebase.google.com/docs/firestore/query-data/indexing)
